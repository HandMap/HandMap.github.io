<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"> <title>Measuring size and distance with OpenCV &#8211; Hand Map</title> <meta name="description" content="We look at how we can measure the size and distance from a point of origin for objects using OpenCV"> <meta name="keywords" content="opencv, measurement"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="halve.png"> <meta name="twitter:title" content="Measuring size and distance with OpenCV"> <meta name="twitter:description" content="We look at how we can measure the size and distance from a point of origin for objects using OpenCV"> <meta name="twitter:site" content="@nathangloverAUS"> <meta name="twitter:creator" content="@nathangloverAUS"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="Measuring size and distance with OpenCV"> <meta property="og:description" content="We look at how we can measure the size and distance from a point of origin for objects using OpenCV"> <meta property="og:url" content="https://handmap.github.io/measuring-size-and-distance-opencv/"> <meta property="og:site_name" content="Hand Map"> <meta property="og:image" content="https://handmap.github.io/images/halve.png"> <link rel="canonical" href="https://handmap.github.io/measuring-size-and-distance-opencv/"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Feed --> <link type="application/atom+xml" rel="alternate" href="https://handmap.github.io/feed.xml" title="Hand Map" /> <!-- Favicons --> <link rel="shortcut icon" type="image/png" href="https://handmap.github.io/favicon.png" /> <link rel="shortcut icon" href="https://handmap.github.io/favicon.ico" /> <!-- CSS --> <link rel="stylesheet" type="text/css" href="https://handmap.github.io/assets/css/main.css"> <!-- Left Block Image for Posts --> <style type="text/css"> #posts.inner-post-page .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(https://handmap.github.io/images/unsplash-gallery-image-3.jpg) no-repeat;background-size: cover;} </style> <!-- Left Block Images for Home and Pages --> <style type="text/css"> #posts .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(https://handmap.github.io/images/unsplash-image-10.jpg) no-repeat;background-size: cover, cover;} .block-left {background: linear-gradient(rgba(44,45,51,0.9), rgba(44,45,51,0.9)), url(https://handmap.github.io/images/home.png) no-repeat;background-size: cover;} </style> </head> <body id="posts" class="inner-post-page"> <div class="block-left"> <div class="content"> <a href="https://handmap.github.io" class="logo"><img src="https://handmap.github.io/images/halve.png"></a> <div class="post-title-section"> <div class="section-line">Posts <em>/</em></div> <h1 class="section-title">Measuring size and distance with OpenCV </h1> <ul class="tags"> <li><a href="https://handmap.github.io/tags#opencv">opencv</a></li> <li><a href="https://handmap.github.io/tags#measurement">measurement</a></li> </ul> <div class="section-line reverse"><a href="https://handmap.github.io/posts">Back to posts</a> <em>/</em></div> </div> </div> </div> <div class="block-right"> <div class="share-buttons"> <a href="https://twitter.com/intent/tweet?text=https://handmap.github.io/measuring-size-and-distance-opencv/" class="btn btn_twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a> <a href="https://www.facebook.com/sharer/sharer.php?u=https://handmap.github.io/measuring-size-and-distance-opencv/" class="btn btn_facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a> <a href="https://plus.google.com/share?url=https://handmap.github.io/measuring-size-and-distance-opencv/" class="btn btn_google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a> </div> <a href="../posts.html" title="posts" class="posts-menu-icon"></a> <a title="projects" class="projects-menu-icon"> <span></span> </a> <div class="inner-post content"> <div class="date-highlight">19 Mar 2017</div> <h2 id="introduction">Introduction</h2> <hr /> <p>Today while trying to bring all the various components I have so far together, I discovered another important aspect I needed to investigate in order for all this work to be worthwhile. Measurement and scale of the data I capture! Itâ€™s all well and good to detect a hand in am image and draw lines from the center of the hand, but that information will be pretty useless without accurate measurements of those lines.</p> <h2 id="concept">Concept</h2> <hr /> <p>The idea for this system is based loosely on the image below</p> <figure> <img src="https://handmap.github.io/images/posts/2017-03-19/hand-measurement-design-idea.png" alt="Measurement of Hand concept" /> <figcaption>Measurement of Hand concept</figcaption> </figure> <p>The sensor box will sit on the hand and will be defined as a constant size. This means that we can use the sensor as our scaling index for measuring how far and how long different points on the hand are.</p> <h2 id="requirements">Requirements</h2> <hr /> <p>Below are a list of requirements the measurement system needs to meet:</p> <h3 id="scaling-object-detection">Scaling Object Detection</h3> <hr /> <p>We need a way to find the object we are going to be using for scaling; in this case it is obviously our blue (or yellow sensor). This will likely be done using one of the previously outlined methods from my previous posts; RGB &amp; HSV detection.</p> <h2 id="implementation">Implementation</h2> <hr /> <p>The implementation for this concept has already been outlined in another great tutorial by <a href="http://www.pyimagesearch.com/2016/03/28/measuring-size-of-objects-in-an-image-with-opencv/">Adrian Rosebrock</a>.</p> <p>First he loads in the image, converts it to grayscale and blurs is slightly.</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s">"image"</span><span class="p">])</span>
<span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
<span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div> <p>Next edge detection (Canny) is performed on the grayscale image; followed by 1 iteration of dialation and erotion to remove any background noise.</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">edged</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">edged</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="n">edged</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">edged</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">erode</span><span class="p">(</span><span class="n">edged</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div> <p>The contours are found in the edge detection map from before.</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">cnts</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">edged</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)</span>
<span class="n">cnts</span> <span class="o">=</span> <span class="n">cnts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">imutils</span><span class="o">.</span><span class="n">is_cv2</span><span class="p">()</span> <span class="k">else</span> <span class="n">cnts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div> <p>The contours are sorted left to right, meaning that for this example the LEFT-most object is used as our scale.</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="n">cnts</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">contours</span><span class="o">.</span><span class="n">sort_contours</span><span class="p">(</span><span class="n">cnts</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">159</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">165</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
          <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
<span class="n">refObj</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div> <p>Now each contour is looped over; if it doesnâ€™t extend to a large enough size it is ignored. We also compute tha bounding box around the large contoured mass and draw a point in the top-left, top right, bottom left and bottom right of the mass. We finally compute the center point of the box</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cnts</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">continue</span>

    <span class="n">box</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">box</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">BoxPoints</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="k">if</span> <span class="n">imutils</span><span class="o">.</span><span class="n">is_cv2</span><span class="p">()</span> <span class="k">else</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boxPoints</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
    <span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">"int"</span><span class="p">)</span>

    <span class="n">box</span> <span class="o">=</span> <span class="n">perspective</span><span class="o">.</span><span class="n">order_points</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>

    <span class="n">cX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">box</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">cY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">box</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div> <p>If the contour weâ€™re examining is the first (left most), then it is the reference object for our scale. We compute the middle point of this object and then compute the Euclidean distance between the middle points to construct a new reference object.</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="n">refObj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">bl</span><span class="p">)</span> <span class="o">=</span> <span class="n">box</span>
    <span class="p">(</span><span class="n">tlblX</span><span class="p">,</span> <span class="n">tlblY</span><span class="p">)</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">bl</span><span class="p">)</span>
    <span class="p">(</span><span class="n">trbrX</span><span class="p">,</span> <span class="n">trbrY</span><span class="p">)</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">br</span><span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">euclidean</span><span class="p">((</span><span class="n">tlblX</span><span class="p">,</span> <span class="n">tlblY</span><span class="p">),</span> <span class="p">(</span><span class="n">trbrX</span><span class="p">,</span> <span class="n">trbrY</span><span class="p">))</span>
    <span class="n">refObj</span> <span class="o">=</span> <span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="p">(</span><span class="n">cX</span><span class="p">,</span> <span class="n">cY</span><span class="p">),</span> <span class="n">D</span> <span class="o">/</span> <span class="n">args</span><span class="p">[</span><span class="s">"width"</span><span class="p">])</span>
    <span class="k">continue</span>
</code></pre></div> <p>We draw the contours onto the image and stack the reference coordinates and the object weâ€™re examining coordinates for use in the next part.</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">orig</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">"int"</span><span class="p">)],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="p">[</span><span class="n">refObj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">"int"</span><span class="p">)],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">refCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">refObj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">refObj</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">objCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">box</span><span class="p">,</span> <span class="p">(</span><span class="n">cX</span><span class="p">,</span> <span class="n">cY</span><span class="p">)])</span>
</code></pre></div> <p>Finally we use the reference coordinates and the object coordinates to compute and display distance vectors from each of the reference objects corners to the respective corner on the object we found, using the reference distance to calculate the accurate scaled distance.</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># loop over the original points</span>
<span class="k">for</span> <span class="p">((</span><span class="n">xA</span><span class="p">,</span> <span class="n">yA</span><span class="p">),</span> <span class="p">(</span><span class="n">xB</span><span class="p">,</span> <span class="n">yB</span><span class="p">),</span> <span class="n">color</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">refCoords</span><span class="p">,</span> <span class="n">objCoords</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="c"># draw circles corresponding to the current points and</span>
    <span class="c"># connect them with a line</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">xA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">yA</span><span class="p">)),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">xB</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">yB</span><span class="p">)),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">xA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">yA</span><span class="p">)),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">xB</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">yB</span><span class="p">)),</span>
             <span class="n">color</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c"># compute the Euclidean distance between the coordinates,</span>
    <span class="c"># and then convert the distance in pixels to distance in</span>
    <span class="c"># units</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">euclidean</span><span class="p">((</span><span class="n">xA</span><span class="p">,</span> <span class="n">yA</span><span class="p">),</span> <span class="p">(</span><span class="n">xB</span><span class="p">,</span> <span class="n">yB</span><span class="p">))</span> <span class="o">/</span> <span class="n">refObj</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="p">(</span><span class="n">mX</span><span class="p">,</span> <span class="n">mY</span><span class="p">)</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">((</span><span class="n">xA</span><span class="p">,</span> <span class="n">yA</span><span class="p">),</span> <span class="p">(</span><span class="n">xB</span><span class="p">,</span> <span class="n">yB</span><span class="p">))</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="s">"{:.1f}in"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">mX</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mY</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)),</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c"># show the output image</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">"Image"</span><span class="p">,</span> <span class="n">orig</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div> <p>Below is an example of it using a bottle cap (estimated to be about 0.995inches) calculating the distance to the a hand.</p> <figure> <img src="https://handmap.github.io/images/posts/2017-03-19/hand-measurement-large-box.png" alt="Hand measurement large box" /> <figcaption>Hand measurement large box</figcaption> </figure> <h2 id="problems">Problems</h2> <hr /> <p>Below are a list of the problems the current system has that will need to be addressed of worked around.</p> <h3 id="large-contours">Large Contours</h3> <hr /> <p>Because the hand detected above is considered a single contour it gives us a box that isnâ€™t particularly useful, as not of the points it gives us distances for are in helpful places. The center point is also off due to the thumb extending the box out to the right.</p> <p>In order to test how well it handles multiple points, I had to cheat a little bit for now and just cut a line at the base of each finger to convince the program that the handle is made up of six pieces.</p> <p>The results can be seen below and clearly offer much more usable information:</p> <figure> <img src="https://handmap.github.io/images/posts/2017-03-19/hand-measurement-piece-01.png" alt="Hand measurement palm" /> <img src="https://handmap.github.io/images/posts/2017-03-19/hand-measurement-piece-02.png" alt="Hand measurement thumb" /> <img src="https://handmap.github.io/images/posts/2017-03-19/hand-measurement-piece-03.png" alt="Hand measurement index" /> <figcaption>Hand measurement</figcaption> </figure> <h3 id="depth-of-field">Depth of Field</h3> <hr /> <p>This issue is the biggest drawback of using this method, mainly because it limits our systems use to situations where the hand is flat and the camera processing the hand is directly or atleast really close to 90 degrees from the hands plain. The image below displays what I mean:</p> <figure> <img src="https://handmap.github.io/images/posts/2017-03-19/hand-depth-of-field-issue.png" alt="Depth of View issues" /> <figcaption>Depth of View issues</figcaption> </figure> <p>The index finger and middle finger of the model should be fairly similar in length on a typical hand, however they would be measured and return a result that has the index finger being atleast half the size purely because of the angle at which weâ€™re capturing the hand at.</p> <h2 id="references">References</h2> <hr /> <p>Measuring size of objects in an image with OpenCV - <a href="http://www.pyimagesearch.com/2016/03/28/measuring-size-of-objects-in-an-image-with-opencv/">http://www.pyimagesearch.com/2016/03/28/measuring-size-of-objects-in-an-image-with-opencv/</a></p> <br> <a href="https://twitter.com/intent/tweet?text=https://handmap.github.io/measuring-size-and-distance-opencv/" class="btn btn_twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a> <a href="https://www.facebook.com/sharer/sharer.php?u=https://handmap.github.io/measuring-size-and-distance-opencv/" class="btn btn_facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a> <a href="https://plus.google.com/share?url=https://handmap.github.io/measuring-size-and-distance-opencv/" class="btn btn_google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a> <nav class="pagination"> <a href="https://handmap.github.io/opencv-colour-tracking-unity3d/" class="pagination_pager" title="OpenCV colour tracking in Unity3D ">previous</a> <a href="#" class="pagination_pager disabled">next</a> </nav> </div> </div> <!-- JS --> <script src="https://handmap.github.io/assets/js/main.min.js"></script> <div class="overlay"> <ul class="projects-menu"> <li style="background:url(https://github.com/HandMap/HandMap.github.io/blob/master/images/project.jpg) center center no-repeat;"> <a href="https://handmap.github.io" class="inactive" target="_blank" rel="nofollow external"> <span> Hand Map Project <br><em>in progress</em> </span> </a> </li> </ul> </div> </body> </html>
